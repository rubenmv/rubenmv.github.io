<!DOCTYPE html>
<html>
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <title>
  
  Blog &middot; Rubén Martínez Vilar
  
  </title>
  <!-- CSS -->
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link href='http://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Roboto+Slab:700,400' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">
  <!--[if lte IE 8]>
  <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/grids-responsive-min.css">
  <!--<![endif]-->
  <link rel="stylesheet" href="/css/main.css">
  <!-- Icons -->
  <link rel="shortcut icon" href="/img/favicon.ico">
  <!-- RSS -->
  <!-- <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> -->
</head>

<body>
  <header class="main-header">
    <!-- MAIN MENU -->
<nav class="site-menu pure-menu pure-menu-horizontal">
  <a href="/" class="pure-menu-heading pure-menu-link">Rubén Martínez Vilar</a>
  <ul class="pure-menu-list">
    <li class="pure-menu-item"><a class="pure-menu-link" href="/#about">About</a></li>
    <li class="pure-menu-item"><a class="pure-menu-link" href="/#projects">Projects</a></li>
    <li class="pure-menu-item"><a class="pure-menu-link" href="/blog/#posts">Blog</a></li>
    <li class="pure-menu-item"><a class="pure-menu-link" href="/#contact">Contact</a></li>
    <li class="pure-menu-item"><a class="pure-menu-link" href="https://dl.dropboxusercontent.com/u/15074300/RubenMartinezVilar-CV.pdf">CV</a></li>
  </ul>
</nav>

<div class="pure-menu pure-menu-horizontal">
    <ul class="pure-menu-list">
        <li class="pure-menu-item pure-menu-selected"><a href="#" class="pure-menu-link">Home</a></li>
        <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            <a href="#" id="menuLink1" class="pure-menu-link">Contact</a>
            <ul class="pure-menu-children">
                <li class="pure-menu-item"><a href="#" class="pure-menu-link">Email</a></li>
                <li class="pure-menu-item"><a href="#" class="pure-menu-link">Twitter</a></li>
                <li class="pure-menu-item"><a href="#" class="pure-menu-link">Tumblr Blog</a></li>
            </ul>
        </li>
    </ul>
</div>
  
  </header>
  <div class="page-content">
    <article id="posts" class="posts">
  <h2>Here is where I write about stuff</h2>
  
  <div>
    <h3 class="post-title">
    <a href="/blog/2015/This-is-my-second-post/">
    This is my second post
    </a>
    </h3>
    <span class="post-date">01 Jun 2015</span>
    <!-- <p>This is my second post, to test out this piece of shit.</p>
 -->
  </div>
  
  <div>
    <h3 class="post-title">
    <a href="/blog/2015/welcome-to-jekyll/">
    Welcome to Jekyll!
    </a>
    </h3>
    <span class="post-date">23 May 2015</span>
    <!-- <p>You’ll find this post in your <code>_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code>jekyll serve --watch</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>To add new posts, simply add a file in the <code>_posts</code> directory that follows the convention <code>YYYY-MM-DD-name-of-post.ext</code> and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">&quot;Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">&#39;Tom&#39;</span><span class="p">)</span>
<span class="c1">#=&gt; prints &#39;Hi, Tom&#39; to STDOUT.</span></code></pre></div>

<p>Check out the <a href="http://jekyllrb.com">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://github.com/jekyll/jekyll-help">Jekyll’s dedicated Help repository</a>.</p>

 -->
  </div>
  
  <div>
    <h3 class="post-title">
    <a href="/blog/2015/Tests-trampas-y-enemigos/">
    Tests de trampas y enemigos
    </a>
    </h3>
    <span class="post-date">15 May 2015</span>
    <!-- <p>Una pequeña actualización sobre el progreso del desarrollo del videojuego: durante esta primera mitad de Mayo he dedicado el tiempo, además de a la documentación, que la tenía un poco abandonada, también a preparar la estructura del juego, el sistema de pantallas y preparar/separar el generador de niveles para utilizarlo en la pantalla de mazmorra. También he comenzado a implementar enemigos y trampas.</p>

<h2 id="enemigos">Enemigos</h2>
<p>En cuanto a los enemigos de momento tengo algo muy básico, pero he estado sobretodo aprendiendo a manejar las animaciones con Unity, a transicionar de una a otra y también a probar las hitbox cuando el jugador toca o ataca a los enemigos y viceversa ya que, al tener un estilo visual peculiar, con sprites 2D en entornos 3D, es necesario jugar con colliders (tienen que ser 3D) para ver cual es la mejor configuración. Con esto quiero decir que tenemos sprites que son planos, por lo que la profundidad en <strong>z</strong> la debemos determinar manualmente, de manera que la detección cuando el jugador ataca sea correcta pero que al pasar por al lado de un enemigo no colisione sin que realmente parezca que lo haya tocado.</p>

<p>He agregado un <strong>efecto de partículas</strong> para simular <strong>sangre</strong> cuando un enemigo muere, así como un efecto de giro para hacerlo más interesante visualmente.</p>

<p>En las próximas semanas iré <strong>mejorando la IA</strong>, sin algo demasiado complicado, pero quiero que los goblins se acerquen hacia el jugador para atacarle activamente en vez de simplemente patrullar de un lado a otro.</p>

<iframe src="http://gfycat.com/ifr/UnrulyDisfiguredFlee" frameborder="0" scrolling="no" width="432" height="304" style="-webkit-backface-visibility: hidden;-webkit-transform: scale(1);"></iframe>

<p>También he estado jugando con la cámara y los sprites, para que funcionen como si fueran de tipo <strong>billboard</strong>, con lo que siempre estarían mirando hacia la cámara. Esto es una técnica muy utilizada en videojuegos, inicialmente incluso Doom incluía los persoajes de esta manera, pero más tarde se comenzó a relegar a otros elementos como plantas y árboles, reduciendo así la cantidad de objetos 3D y la subsecuente carga gráfica.</p>

<p>Aún sigo teniendo problemas en mantener a los sprites mirando a la cámara mientras me muevo por la escena al mismo tiempo, pero esto es algo secundario que implementaré mediante algún shader si tengo tiempo antes de la entrega del proyecto.</p>

<h2 id="trampas">Trampas</h2>
<p>Con las trampas he pasado un poco más de tiempo y ya tengo los cuatro tipos básicos que tenía pensado para el juego, al menos los cuatro más “complejos”.</p>

<ol>
  <li><strong>Panel de pinchos en suelo</strong>: son paneles de los que surgen unos pinchos que dañan al jugador cuando los toca. El panel se activa cada cierto tiempo o cuando el jugador se posiciona encima, según el modo que tenga activo.</li>
  <li><strong>Panel de pinchos en pared</strong>: similar al de suelo, estos pinchos son más largos y funcionan siempre en modo automático.</li>
  <li><strong>Dispensador de flechas</strong>: un dispensador en la pared que lanza un dardo/flecha a toda velocidad cuando detecta al jugador pasando por delante. Para esto se lanza un rayo mediante un raycast desde la zona baja de la trampa y en dirección hacia adelante de la trampa.</li>
  <li><strong>Roca gigante</strong>: se trata de una roca gigantesca que avanza por un pasillo. Se activa cuando el jugador pisa una placa de presión o trigger. Se puede llegar a destruir cuando choca contra una pared.</li>
</ol>

<p>Los paneles de pinchos, tanto los de pared como los de suelo, tienen un tiempo de comienzo y de repetición, por lo que se pueden sincronizar para que se activen todos a la vez o en diferentes patrones.</p>

<iframe src="http://gfycat.com/ifr/UnrulyFlawedClam" frameborder="0" scrolling="no" width="416" height="324" style="-webkit-backface-visibility: hidden;-webkit-transform: scale(1);"></iframe>

<p>Lo siguiente es integrar todo esto en la escena con el generador de mazmorra.</p>
 -->
  </div>
  
  <div>
    <h3 class="post-title">
    <a href="/blog/2015/Tests-generacion-en-Unity/">
    Tests de generación en Unity
    </a>
    </h3>
    <span class="post-date">05 May 2015</span>
    <!-- <p>Ya hemos visto tres algoritmos para la generación procedimental de laberintos y
mazmorras. Ahora dejo una implementación en Unity donde podemos realizar pruebas
sobre estos algoritmos.</p>

<p><a href="rubenmv.github.ioresources/TestsGenerators/TestsGenerators.html">Accede a la aplicación desde aquí</a></p>

<p><strong>IMPORTANTE</strong>: Esta demostración funciona sobre el <strong>plugin/player de Unity</strong>
para navegadores, que se puede conseguir en <a href="https://unity3d.com/webplayer">este enlace</a>. Chrome no soporta
este tipo de plugins, por lo que se recomienda utilizar <strong>Firefox</strong>.</p>

<h3 id="notas-sobre-los-test">NOTAS SOBRE LOS TEST:</h3>

<p><strong>Growing Tree</strong>: Hace cada paso automáticamente pero podemos escoger el tiempo
entre paso y paso. La opción <strong>Random</strong> modifica como actúa el algoritmo y en
vez de utilizar una pila escoge el siguiente nodo aleatoriamente.</p>

<p><strong>Cellular automata</strong>: Permite escoger el ancho y largo del mapa, se recomienda
jugar con estos valores. <strong>Passes</strong> indica el número de iteraciones, es decir,
de veces que se aplica el algoritmo de autómata. <strong>Prob. Walls</strong> indica el
número inicial de paredes que se van a generar, se recomiendo mantener en
35-40%.</p>

<p><strong>BSP Tree</strong>: En esta implementación se realiza un número de iteraciones fijo de
7, por lo que siempre hay que pulsar el botón de Step 8 veces para ver la
generación completa. En ocasiones veremos que no se crean más subdivisiones,
esto es debido a que el tamaño mínimo de la habitación no permite más cortes.</p>

<p>En cuanto a las opciones, se permite escoger el tamaño del tablero y las
dimensiones mínimas de la habitación. Se recomienda no bajar de 20 el tamaño de
la aplicación (actualmente hay un posible bug) y probar con tamaños de mazmorra
grandes, más de 75, ya que se entonces se generan más habitaciones y podemos ver
mejor como funciona el algoritmo.</p>
 -->
  </div>
  
  <div>
    <h3 class="post-title">
    <a href="/blog/2015/Generacion-mediante-BSP-Tree/">
    Generación mediante BSP Tree
    </a>
    </h3>
    <span class="post-date">02 Apr 2015</span>
    <!-- <h1 id="particionado-bsp">Particionado BSP</h1>
<p>Esta técnica utiliza el particionado binario para subdividir un espacio utilizando hiperplanos. Las subdivisiones obtenidas son representadas mediante una estructura de datos de tipo árbol, conocida como BSP Tree o Árbol BSP.</p>

<h1 id="por-qu-utilizar-un-rbol-bsp">¿Por qué utilizar un árbol BSP?</h1>
<p>Cuando vamos a generar un mapa de mazmorra, hay muchas maneras de hacerlo, simplemente podríamos generar rectángulos de tamaños y en posiciones aleatorias y crear una habitación en cada uno, pero esto puede llevar a muchos problemas, como la superposición de habitaciones, espacios entre estas demasiado arbitrarios y extraños, como obtener algunas habitaciones muy juntas y otras muy separadas. Si entonces queremos pulir el algoritmo y arreglar estos problemas la complejidad de la solución se vuelve grande y es más difícil de depurar nuevos problemas.</p>

<p>La misma estructura de un árbol binario nos permite dividir el espacio de manera más o menos regular, manteniendo la consistencia entre el espacio entre habitaciones, los tamaños de estas y permitiéndonos unir mediante pasillos basándonos directamente en la unión de los mismos nodos del árbol.</p>

<p>El método procedería de la siguiente manera:</p>

<ol>
  <li>Creamos un plano completo sobre el que vamos a generar las habitaciones de la mazmorra. Este espacio completo es la raíz del árbol.
<img src="images/posts/2015-04-02-Generacion-mediante-BSP-Tree/bsp_1.PNG" alt="bsp tree 1" /></li>
  <li>Escogemos una orientación aleatoria, horizontal o vertical, sobre la que vamos a partir.</li>
  <li>Escogemos un punto en x (horizontal) o en y (vertical) según la orientación escogida y partimos el espacio en dos sub-mazmorras.
<img src="images/posts/2015-04-02-Generacion-mediante-BSP-Tree/bsp_2.PNG" alt="bsp tree 2" /></li>
  <li>Seguimos subdividiendo esas sub-mazmorras generadas pero teniendo cuidado que las divisiones no sean demasiado cerca del borde, ya que debemos ser capaces de poder incluir una habitación en cada una de estas divisiones.</li>
</ol>

<p>Aspecto en la segunda iteración.
<img src="images/posts/2015-04-02-Generacion-mediante-BSP-Tree/bsp_3.PNG" alt="bsp tree 3" /></p>

<p>Aspecto en la última iteración. Cada uno de estos espacios incluirá una habitación.
<img src="images/posts/2015-04-02-Generacion-mediante-BSP-Tree/bsp_8.PNG" alt="bsp tree 8" /></p>

<p><strong>¿Y cuándo nos detenemos?</strong></p>

<p>Tenemos varias opciones:
En cada iteración comprobamos si quedan espacios que puedan ser divididos y en las nuevas áreas se puedan crear al menos una habitación, seguimos dividiendo hasta que no queden espacios que cumplan esta condición. El problema con este método es que al final obtenemos áreas con muy dimensiones similares, por lo que las habitaciones también serán prácticamente iguales.
Otra solución es establecer un número de iteraciones fijo dependiendo del tamaño de la mazmorra, con lo que obtendremos áreas divididas al máximo posible, pero otras que se podrían dividir al menos una vez más, pero se quedan enteras y de esta manera se puede crear un habitación más grande y alargada o una habitación pequeña pero un pasillo largo que la une con otra sección.</p>

<ol>
  <li>Cuando tenemos las divisiones para incluir una sola habitación en cada una de estas, comenzamos a construir la mazmorra. Creamos una habitación de tamaño aleatorio dentro de cada división, es decir, cada hoja del árbol, teniendo en cuenta los límites del espacio.</li>
  <li>Para construir los pasillos que unen las habitaciones recorremos el árbol conectando cada nodo hoja con su hermana. Los nodos hoja son los nodos que no tiene más hijos, al final de cada rama del árbol.</li>
</ol>

<p>El resultado final para el ejemplo que hemos estado viendo sería como se ve en la siguiente imagen.
<img src="images/posts/2015-04-02-Generacion-mediante-BSP-Tree/bsp_9.PNG" alt="bsp tree 9" /></p>

<p>Como vemos las habitaciones dentro de cada espacio se generan en una posición y con dimensiones aleatorias dentro de sus límites, por lo que podemos encontrar habitaciones pequeñas en espacio relativamente grande. Evidentemente estos parámetros se pueden ajustar si se desea que cada habitación rellene lo más en su espacio.</p>

<p>El utilizar un árbol binario nos asegura que después de realizar la primera partición vamos a obtener al menos dos hojas en dos ramas distintas que podemos utilizar como habitaciones de inicio y de final, estando siempre separadas por la raíz, por lo que nunca estarán conectadas directamente y se deberá recorrer primero la mayor parte del resto de habitaciones, algo que es esencial para el tipo de juego que queremos realizar en este caso.</p>

<p>Un segundo ejemplo generado mediante este método:
<img src="images/posts/2015-04-02-Generacion-mediante-BSP-Tree/bsp_9b.PNG" alt="bsp tree 9b" /></p>

<p>Como alternativa podemos utilizar un QuadTree para generar la mazmorra usando este tipo de técnica. En ese caso tendríamos cuatro nodos por cada partición y puede acelerar el proceso de creación, pero la diferencia es realmente mínima en estos casos.</p>
 -->
  </div>
  
  <div>
    <h3 class="post-title">
    <a href="/blog/2015/El-Automata-Celular/">
    El Autómata celular
    </a>
    </h3>
    <span class="post-date">25 Mar 2015</span>
    <!-- <p>El segundo tipo de algoritmo que vamos a estudiar entra dentro de los algoritmos utilizados para representar sistemas naturales, como cuevas, bosques o manadas de animales.</p>

<p>El concepto de <strong>autómata celular</strong> fue presentado originalmente en los <strong>años 40</strong> por Stanislaw Ulam y John Von Neumann cuando trabajaban en el laboratorio nacional de Los Alamos. Fue estudiado ocasionalmente durante las siguientes dos décadas pero no fue hasta los 70 en que <strong>John Horton Conway</strong> creó el “Juego de la vida” (<a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game Of Life</a>) que despertó el interés en el entorno académico.</p>

<h2 id="conways-game-of-life">Conway’s Game Of Life</h2>
<p>Este juego consiste en una serie de puntos llamados células que evolucionan con el tiempo basándose en la interacción con sus vecinas. Si una célula tiene <strong>menos de dos</strong> vecinas, entonces <strong>muere</strong>, debido a la falta de población, con <strong>dos o tres</strong> vecinas se mantiene <strong>viva</strong> durante esa generación, si tiene <strong>más de tres</strong> entonces <strong>muere</strong> por sobrepoblación. Si una célula muerta (un espacio vacío) tiene exactamente tres vecinos, entonces esta se convierte en una célula viva, representando un proceso de reproducción.</p>

<p>Antes de comenzar el juego se establecen ciertas condiciones para la situación inicial, pero a partir de ahí el jugador no tiene más interacción con este, el juego evoluciona por sí solo.</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/Game-Of-Life.gif" alt="Game of life" /></p>

<p>Durante los <strong>años 80 Stephen Wolfram</strong> se ocupó del estudio del autómata celular sobre una sola dimensión, y en 2002 publicó su libro “<strong>Un nuevo tipo de ciencia</strong>”, donde argumenta que este tipo de métodos pueden ser utilizados en otros campos de la ciencia como la criptografía.</p>

<h2 id="aplicacin-para-generacin-procedural-de-cuevas">Aplicación para generación procedural de cuevas</h2>
<p><strong>Jim Badcock</strong> publicó hace unos años su aplicación de los <a href="http://www.jimrandomh.org/misc/caves.html">autómatas celulares en la creación procedimental de cuevas</a>, mostrando su potencial para la representación de sistemas naturales, al menos como base, ya que el proceso requiere un refinamiento posterior.</p>

<p>El <strong>proceso</strong> consiste en lo siguiente:</p>

<ol>
  <li>
    <p>Generamos un lienzo inicial utilizando la técnica de ruido blanco, es decir, dividimos el mapa en celdas y las recorremos decidiendo aleatoriamente si esta se rellena o se queda vacía. Para evitar situaciones no deseables o extrañas establecemos un porcentaje que indique la probabilidad de que esta se convierta en pared. Por ejemplo, decimos que la probabilidad es del 40%, generamos un número aleatorio entre 0 y 100 y si este es inferior o igual al 40 entonces generamos una pared.</p>
  </li>
  <li>Recorremos el mapa de nuevo ahora aplicando las reglas del autómata celular:
    <ul>
      <li>Si la celda es pared y tiene menos de 3 vecinas de tipo pared, entonces se convierte en espacio vacío.</li>
      <li>Si la celda está vacía y tiene 5 o más vecinas de tipo pared, entonces esta también se convierte en pared.</li>
    </ul>
  </li>
  <li>Cuando hemos recorrido todas las celdas el algoritmo termina, aunque es posible realizar más iteraciones, dependiendo de los resultados a obtener.</li>
</ol>

<p>Vamos a ver ejemplos generados a partir de la implementación que he realizado sobre Unity:</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/cellular-automata-1.PNG" alt="Cellular automata 1" />
Tablero inicial generado aleatoriamente con una probabilidad de paredes del 35%.</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/cellular-automata-2.PNG" alt="Cellular automata 2" />
Este es el resultado al terminar el algoritmo con un solo pase, podemos ver que se generan zonas o espacios abiertos distinguibles unos de otros. También observamos uno de los problemas del algoritmo, y es que es poco consistente, y muy frecuentemente obtenemos zonas inconexas que deberemos procesar posteriormente para unirlas al sistema principal de habitaciones. A veces estas zonas desconectadas están separadas simplemente por distancias de 1 o 2 celdas, pero como podemos ver en este mismo ejemplo, en la zona superior derecha tenemos una zona relativamente grande con una separación de la zona principal de al menos 3 celdas, por lo que resultaría difícil determinar programáticamente como esa zona debería unirse.</p>

<p>Por otro lado esto puede ser interesante para juego como Minecraft, donde podemos encontrar en cuevas, con mucha frecuencia, zonas totalmente aisladas a las que se debe acceder usando el pico o la pala. En ese caso específico este algoritmo parece actuar correctamente.</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/cellular-automata-3.PNG" alt="Cellular automata 3" />
Aquí tenemos otro ejemplo, esta vez con dos pases. Ahora hemos conseguido que todos los espacios estén conectados de alguna manera. También se han eliminado celdas sueltas de una unidad al realizar este segundo pase, lo cual puede ser beneficioso para eliminar ruido innecesario pero al mismo tiempo perjudicial porque le quita un poco de la aleatoriedad que podemos encontrar en las cuevas naturales.</p>

<p>Otro problema de realizar este segundo pase es que perdemos la distinción entre las distintas secciones o habitaciones de la cueva, por lo que nos queda un espacio abierto con algunos rincones más cerrados.</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/cellular-automata-4.PNG" alt="Cellular automata 4" />
Con los mismo parámetros pero con diferentes dimensiones. Conseguimos conectar todos los espacios pero el centro está demasiado despoblado.</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/cellular-automata-5.PNG" alt="Cellular automata 5" />
Si subimos la probabilidad de paredes al 40% y al realizar dos pases obtenemos un resultado mejor.</p>

<p>Conclusión
Haciendo varias pruebas puedo llegar a la conclusión de que los mejores resultados los obtengo con una probabilidad de obtener paredes del 35% al 40% y uno o dos pases según este porcentaje, cuanto más se acerca al 40% mejores resultados obtendremos con dos pases que solo con uno.</p>

<p>Uno de los principales problemas con este algoritmo, como ya hemos visto, es el poco control sobre el resultado final, demasiadas aleatoriedad en la creación de los distintos espacios que componen la cueva.</p>
 -->
  </div>
  
  <div>
    <h3 class="post-title">
    <a href="/blog/2015/Growing-Tree-Creando-laberintos/">
    Growing Tree - Creando laberintos
    </a>
    </h3>
    <span class="post-date">03 Feb 2015</span>
    <!-- <p>Vamos a estudiar un poco más a fondo algunos de los algoritmos para la
generación procedural de mazmorras, pero tenemos que empezar por lo básico, un
laberinto.</p>

<p>Existen decenas de algoritmos para la resolución y creación de mazmorras de
manera procedimental, y algunos de los factores imporantes que debemos tener en
cuenta para escoger uno son el coste temporal, la variedad de resultados que nos
permite obtener, la complejidad del mismo algoritmo y la personalización que
podamos realizar sobre este para adaptarlo a nuestro proyecto.</p>

<p>Antes de pasar al algoritmo conocido como Growing Tree debemos repasar
rápidamente ciertos conceptos básicos. Por un lado tenemos los <strong>vértices</strong> o
<strong>nodos</strong>, que en el caso que nos compete, pueden ser llamados <strong>celdas</strong>. Estos
nodos se unen mediante <strong>aristas</strong>, que es básicamente una linea. Una colección
de vértices y aristas es lo que llamamos <strong>grafo</strong>. Si desde una nodo podemos
alcanzar cualquier otro nodo del grafo siguiente las aristas entonces decimos
que es un <strong>grafo conexo</strong>.</p>

<p><img src="2015-02-03-Growing-Tree-Creando-laberintos/grafos-1.png" alt="Grafo conexo" /></p>

<p>Si eliminamos los ciclos del grafo, obtenemos un grafo acíclico, una cuando es
grafo acíclico es conexo, lo que tenemos es llamado un <strong>árbol</strong>.</p>

<p><img src="2015-02-03-Growing-Tree-Creando-laberintos/grafos-2.png" alt="Arbol" /></p>

<p>Una grafo puede estar compuesto por varios árboles, pero existe uno que
comprende todos los nodos de un grafo, tenemos un <strong>árbol de expansión (Spanning
Tree)</strong>.</p>

<p><img src="2015-02-03-Growing-Tree-Creando-laberintos/spanning-tree.png" alt="Arbol de expansion" /></p>

<p>Y los árboles de expansión son la misma esencia de la estructura de los
algoritmos de generación de laberintos.</p>

<p><img src="2015-02-03-Growing-Tree-Creando-laberintos/spanning-tree-is-maze.png" alt="Arbol de expansion laberinto" /></p>

<h1 id="aldous-broder">Aldous-Broder</h1>

<p>Dos investigadores llamados D. Aldous y A. Broder, trabajando
independientemente, estaban estudiando los árboles de expansión cuando diseñaron
el siguiente algoritmo:</p>

<ol>
  <li>
    <p>Escoge un vértice cualquiera.</p>
  </li>
  <li>
    <p>Escoge otro vértice aleatorio entre los vecinos de este. Si el nodo no ha
sido visitado con anterioridad, nos movemos a este y lo agregamos, junto a
la arista, al árbol de expansión.</p>
  </li>
  <li>
    <p>Repetir el paso 2 hasta que todos los vértices hayan sido visitados.</p>
  </li>
</ol>

<p>Un algoritmo extremadamente simple que selecciona cualquier de todos los
posibles árboles de expansión del grafo con la misma probabilidad. Tambien hay
que decir que es una técnica muy ineficiente, ya que su naturaleza aleatoria a
la hora de escoger el nodo hace que se puedan volver a visitar los mismos
vértices una y otra vez.</p>

<p><img src="2015-02-03-Growing-Tree-Creando-laberintos/aldous-broder.gif" alt="Aldous-Broder" /></p>

<p>Posteriormente este método fue mejorado por otros como el algoritmo de Wilson,
entre otros, pero vamos a pasar directamente al que nos interesa estudiar, que
entra dentro de los algoritmos que hacen uso de la técnica de escoger un nodo
aleatoriamente en cada paso, también conocido como <strong>Drunken Walk</strong>, aunque en
este caso hay matices.</p>

<h2 id="growing-tree">Growing Tree</h2>

<p>Entre los algoritmos de generación de laberintos, el llamado Growing Tree es
quizás el más personalizable. La premisa básica es la de escoger un nodo del
grafo aleatoriamente y agregarlo a una lista de “celdas activas”. En cada paso
posterior miramos a uno de los nodos de la lista y agregamos uno de sus vecinos
<strong>no visitados</strong>. Si el nodo no tiene más vecinos sin visitar, lo quitamos de la
lista y probamos con otro nodo. El proceso termina cuando la lista se queda
vacía.</p>

<p>Debemos que tener en cuenta que cada celda o nodo tiene 4 bordes que tocan con
otros nodos o con el exterior de la mazmorra, por lo que cada nodo deberá ser
visitado 4 veces. Esto no se produce en la misma pasada, sino que al
introducirlos en la lista y luego hacer el backtracking nos vamos asegurando que
ese nodo tiene aún bordes libres, en caso contrario lo podemos sacar y lo damos
como cerrado.</p>

<p>Cuando estamos comprobando un vecino debemos determinar si se ha de crear un
pared según el caso. Para los bordes que den al exterior de los límites de la
mazmorra simplemente creamos la pared, cuando nos movemos a una nueva celda no
visitada antes, entonces simplemente creamos pasillo entre estas, pero cuando
nos topamos con otro nodo que ya está en la lista de activos entonces creamos
una pared en ese borde y nos movemos a otro de los vecinos. Este mismo proceso
nos permite que siempre se pueda alcanzar cualquier celda desde otra.</p>

<p>Un aspecto interesante es como el uso de distintas heurísticas para seleccionar
un nodo de la lista de activos cambia el comportamiento de este algoritmo. Por
ejemplo, si escogemos el nodo más reciente, el último que se agregó a la lista,
obtenemos un comportamento de pila recursiva. Este comportamiento es el mismo
que encontramos en otro algoritmo llamado Recursive Backtracker. Si escogemos un
nodo aleatoriamente, entonces tenemos un comportamiento del estilo del algoritmo
de Prim.</p>

<p>En la implementación que he realizado sobre Unity podemos ver el comportamiento
al usar el nodo más reciente agregado a la lista.</p>

<p><img src="2015-02-03-Growing-Tree-Creando-laberintos/maze-growing-tree-example-1.gif" alt="Growing Tree Maze 1" /></p>

<p>Y también cuando escogemos un nodo aleatorio cada vez, como en el algoritmo de
Prim.</p>

<p><img src="2015-02-03-Growing-Tree-Creando-laberintos/maze-growing-tree-example-2.gif" alt="Growing Tree Maze 2" /></p>

<p>Modificando el algoritmo incluso podríamos hacer que se generen habitaciones en
vez de pasillos. El uso de este método similar al Recursive Backtracker nos
permite determinar y marcar cuando una habitación se ha completado, momento en
el que se comienzan a desapilar nodos y retoma el camino hacia la creación de
otra habitación. Pero la cosa se complica si queremos tener habitaciones y
pasillos en es mismo mapa, por ello este algoritmo no es de mucha utilidad más
allá de la generación de laberintos.</p>

<h2 id="conclusin">Conclusión</h2>

<p>El algoritmo de Growing Tree es interesante en el sentido en que se puede
personalizar y ampliarlo para generar algo más que laberintos, ensanchando los
pasillos o uniendo los adyacentes para generar habitaciones y obtener una
estructura más similar a lo que busco para el videojuego que quiero crear, pero
como veremos hay otros algoritmos que son más adecuados y rápidos para generar
mapas grandes.</p>

<p>Podemos decir finalmente que este algoritmo tiene sus <strong>ventajas</strong>:</p>

<ul>
  <li>Esta basado en técnicas muy simple.</li>
  <li>Es flexible y puede comportarse como otros algoritmos según su
implementación.</li>
</ul>

<p>Pero también hay algunas <strong>desventajas</strong>:</p>

<ul>
  <li>No es el algoritmo más rápido de por sí, y habría que utilizar una mezcla con
árboles de partición (BSP, Quadtree) para generar laberintos realmente grandes.</li>
  <li>Generalmente solo se puede utilizar para la creación laberintos, otro tipo de
estructuras como mazmorras o cuevas están fuera del alcance.</li>
</ul>
 -->
  </div>
  
  <div>
    <h3 class="post-title">
    <a href="/blog/2015/Jugando-con-mazmorras/">
    Jugando con mazmorras
    </a>
    </h3>
    <span class="post-date">21 Jan 2015</span>
    <!-- <p>Después de haber visto la definición de lo que significa generar contenido con procedimientos, vamos a hacer un repaso por la historia de los videojuegos para estudiar brevemente algunos de los más relevantes en la aplicación de técnicas de este área.</p>

<h2 id="los-limitados-comienzos">Los limitados comienzos</h2>

<h3 id="rogue-1980">Rogue (1980)</h3>

<p>Al contrario de hoy día en el que tenemos disponibles gigabytes de
memoria para mantener los recursos de alta calidad de un videojuego, en
la historia temprana de los videojuegos no era aceptable debido a las
grandes limitaciones de memoria, por lo que podemos encontrar muchos
juegos de aquella época que utilizan de alguna manera alguna técnica de
generación procedural de contenido. De entre estos quizá el ejemplo más
memorable es <strong>Rogue</strong>.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/1980-rogue.jpg" alt="Rogue" /></p>

<p>Este juego utiliza caracteres ASCII para dibujar los todos elementos
visuales y aplica algoritmos de generación procedimental de mazmorras y
de colocación de objetos. Esto proporciona una jugabilidad casi
infinita, donde dos partidas nunca son iguales.</p>

<p>De hecho su popularidad a acuñar el término del subgénero de videojuegos
llamados “Rogue-Like”. La influencia de Rogue la hemos podido ver en una
gran variedad de videojuegos publicados posteriormente y hasta el día de
hoy.</p>

<h3 id="elite-1984">Elite (1984)</h3>

<p>Desarrollado por Acornsoft y publicado en 1984 para la computadora BBC
Micro y la familia Electron, Elite es un juego que mezcla la simulación
de pilotaje de naves espaciales con el comercio espacial en un entorno
estilo sandbox donde el jugador escoge planetas que visitar y en la
vecindad de estos puede encontrar piratas a los que enfrentarse, objetos
como meteoritos que pueden dañar la nave.</p>

<p>La nave entonces se puede atracar en los planetas y realizar negocios
con el dinero de las recompensas obtenido al eliminar piratas y otras
actividades.</p>

<p>Además de su excelente implementación de gráficos 3D, de tipo wireframe,
que en su momento impresionó porque exprimía al máximo las modestas
máquinas donde se publicó, donde realmente destaca en comparación con el
resto de juegos de comercio espacial era su universo generado
procedimentalmente, incluyendo las posiciones de los planetas, nombres,
políticas y descripciones.</p>

<p>Es un juego con una entrada de dificultad un poco dura, pero una vez te
haces a los controles es bastante gratificante y su naturaleza
procedural proporciona muchas horas de juego.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/1984-elite.png" alt="Elite" /></p>

<p>El éxito de este juego hizo que fuera portado, con una rebaja
considerable en el aspecto técnico, a la Commodore 64 y otras
plataformas como el Apple II. En Marzo de 2008, la <a href="http://en.wikipedia.org/wiki/Next_Generation_%28magazine%29"><em>revista Next Generation</em></a> lo
declaró el número 1 de los mejores juegos de la década de los 80,
definiéndolo como predecesor de lo que fueron más tarde juegos como la
saga Wing Commander o Grand Theft Auto.</p>

<h3 id="the-sentinel-1986">The Sentinel (1986)</h3>

<p>Creado por Geoff Crammond y publicado bajo el sello de Firebird en 1986
para varias máquinas como la BBC Micro, Comodore 64, Amstrad CPC, ZX
Spectrum, Atari ST, Amiga y PC. Se trata de uno de los primeros juegos
que incluían un aspecto 3D con polígonos rellenos.</p>

<p>En este juego tomas el papel de un robot con habilidades telepáticas con
las que puedes recoger y colocar objetos del entorno desde una vista en
primera persona. El objetivo es el de acabar con el centinela que está
en la parte más alta del nivel. Este centinela gira constantemente
vigilando el terreno, si te descubre comienza a absorber tu energía. Hay
que llegar a la cima y disparar a la base en la que se asienta el
centinela, pero el jugador por puede avanzar simplemente utilizando las
teclas, sino que tiene que encontrar los robots esparcidos por el
terreno que permiten teletransportarse a ellos, lo cual hace que la
energía disminuya, pero se puede recuperar absorbiendo objetos del
entorno, como árboles.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/1986-the-sentinel.jpg" alt="The Sentinel" /></p>

<p>Claramente las limitaciones de memoria de los microcomputadores de 8
bits eran un impedimento para almacenar los 10.000 mundos que presumía
tener. Aquí es donde entraba la generación de contenido procedural,
donde cada mundo se generaba desde un pequeño paquete de datos: un
número de 8 dígitos obtenido al terminar el mundo anterior. Estos
dígitos eran diferentes según el éxito del jugador en ese mundo,
dependiendo de la cantidad de energía con que terminara el objetivo
principal, por lo que se intentaba balancear la dificultad del juego en
base a esto. Debido a que no todos los mundos podían ser testeados
durante el desarrollo, dejaron la posibilidad de volver a un mundo
anterior (usando los números de 8 dígitos) y completandolo con una
cantidad diferente de energía.</p>

<h2 id="una-nueva-generacin">Una nueva generación</h2>

<h3 id="diablo-1996">Diablo (1996)</h3>

<p>Publicado 16 años después de Rogue, <strong>Blizzard Entertainment</strong> condujo
el género de los rogue-like a la era moderna con <strong>Diablo</strong>. Se trata de
un RPG de acción que implementó elementos procedimentales de una manera
tan espléndida que los jugadores comenzaron a pasar cientos de horas
jugándolo sin llegar a aburrirse.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/1996-diablo.jpg" alt="Diablo" /></p>

<p>En concreto, hay dos aspectos a destacar de la generación procedimental
en Diablo:</p>

<ul>
  <li>
    <p>Al igual que sus antecesores, como Rogue, la estructura de las mazmorras se generaba de manera aleatoria pero en vez de simples caracteres ASCII este introducía gráficos 2D imitando una perspectiva tridimensional isométrica de gran detalle.</p>
  </li>
  <li>
    <p>La generación de ítems también era aleatoria, introduciendo una categoría de colores que clasificaba los objetos por rareza donde las estadísticas de estos se generaban “al vuelo” en el momento de creación.</p>
  </li>
</ul>

<h3 id="spore-2008">Spore (2008)</h3>

<p>Nos movemos más de una década para hablar de Spore, un juego estilo
god-like, que es el término que se refiere a los juegos en los que no
tomas el control de un personaje en el mundo, sino que tomas el papel de
creador, como un dios que desde una lugar apartado maneja los hilos de
ciertos elementos del juego, moldeando así su evolución.</p>

<p>El objetivo de Spore es la de crear un organismo multicelular que irá
evolucionando, sobreviviendo al entorno o muriendo en el intento. El
jugador decide, antes de comenzar la partida, las distintas etapas de
evolución del organismo, o para decirlo más claro, que características
físicas desarrollará en cada etapa. El juego conduce al jugador durante
el desarrollo de esta especie en un mundo donde puede interactuar con
otras tribus de especies diferentes, luchar bestias salvajes,
desarrollar el aspecto social e inteligente de su especie e incluso
realizar exploración espacial en etapas futuras.</p>

<p>El juego se desarrolló en Maxis, creadores de Los Sims, entre otros, con
el diseñador principal Will Wright y publicado por Electronic Arts. Fue
un éxito de crítica.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/2008-spore.jpg" alt="Spore" /></p>

<p>Spore destaca por su uso masivo de la generación de contenido dinámico
utilizando técnicas procedurales. No solo los <strong>mundos</strong> se crean de
esta manera, sino que los movimientos de las <strong>criaturas</strong> en sí son
<strong>animadas procedimentalmente</strong>, aún dando al jugador grandes
posibilidades de creación, pudiendo agregar o quitar miembros a su
gusto. Para ello el creador de especies proporciona una gran variedad de
miembros predefinidos que se pueden colocar como se desee, es el mismo
jugador el que decide qué puede ser más útil a nivel evolutivo, o
simplemente crear algo totalmente bizarro y comprobar cómo se desarrolla
en el entorno.</p>

<p>Por otro lado incluso la <strong>música</strong> de <strong>Brian Eno</strong> es creada usando un
compositor algorítmico, lo que se conoce como <a href="http://en.wikipedia.org/wiki/Generative_music"><strong><em>música
generativa</em></strong></a>, término
popularizado por él mismo. De esta manera la música se puede adaptar
sobre la marcha a la gran variedad de situaciones.</p>

<h3 id="la-era-independiente">La era independiente</h3>

<h3 id="spelunky-2008">Spelunky (2008)</h3>

<p>Creado por <strong>Derek Yu</strong> y publicado como freeware para sistemas Windows,
se trata de un juego independiente de exploración de cuevas 2D al puro
estilo Indiana Jones. El objetivo es el de llegar al final de cada nivel
evitando trampas y criaturas, al mismo tiempo que se van recogiendo
tesoros y salvando princesas perdidas. Sigue la premisa del clásico
juego Spelunker de 1983 pero en un mundo creado proceduralmente en cada
nueva partida.</p>

<p>Se hizo un remake en 2013 pero aún se puede encontrar la versión
original freeware incluyendo el código fuente para <strong>Gamemaker</strong>.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/2008-spelunky.jpg" alt="Spelunky" /></p>

<p>Para generar cada pantalla o nivel se crea una rejilla y se divide en
secciones o habitaciones formadas por varios tiles. A cada habitación se
le asigna un tipo o rol, por ejemplo:</p>

<blockquote>
  <p>0 - habitación que en principio no tiene salida y no forma parte del
camino solución.</p>

  <p>1 - habitación que tiene salida a la izquierda y derecha.</p>

  <p>2 - habitación con salida izquierda, derecha e inferior. Si encima se
une otra del mismo tipo entonces esta también tendrá salida superior.</p>

  <p>3 - habitación con salidas izquierda, derecha y superior.</p>
</blockquote>

<p>Primero hay que colocar una habitación de inicio en la zona superior de
la rejilla de habitaciones, generalmente del tipo 1 o 2.</p>

<p>Cada vez que se coloca una habitación por defecto es de tipo 1. Entonces
de manera aleatoria (utilizando distribución uniforme de 1 a 5) se
escoge la siguiente dirección. Para 1 o 2 se mueve a la izquierda, para
3 o 4 a la derecha. En estos casos ya tenemos la habitación 1 lista con
salidas a estos dos lados. Ahora, cuando obtenemos un 5 entonces hay que
cambiar la habitación de tipo 1 por otra de tipo 2 que siempre tiene una
salida inferior.</p>

<p>Una vez nos movemos a la siguiente habitación realizamos lo mismo, pero
esta vez miramos primero si la anterior era tipo 2 y nos hemos movido
hacia abajo, caso en el que escogemos por defecto una habitación de tipo
2 o 3.</p>

<p>Cuando llegamos a la última fila y la siguiente dirección que obtenemos
es hacia abajo, entonces podemos colocar la salida y ya tenemos el
camino completo. El resto de habitaciones que queden vacías se rellenan
con un tipo 0.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/2008-spelunky-level.png" alt="" /></p>

<p>Finalmente dependiendo de las habitaciones adyacentes que se unan
podemos determinar por métodos probabilísticos que tipo de criaturas o
trampas incluir en cada habitación.</p>

<h3 id="minecraft-2009">Minecraft (2009)</h3>

<p>Minecraft es un juego de estilo sandbox creado originalmente por Markus
“Notch” Persson que más tarde formó la compañía Mojang. Este juego
brinda al usuario con unos aspectos de creatividad y construcción sobre
un mundo compuesto por cubos 3D con texturas que le da un aspecto
simple. Este mundo permite una infinidad de tareas a realizar, como la
exploración de nuevos espacios y cuevas, minería, construcción o
combate. Pero todas estas mecánicas se presentan de una manera simple y
abierta para que el mismo usuario sea capaz de construir sus propias
aventuras en los diferentes modos de juego.</p>

<p>Es posiblemente, junto a Diablo, el juego más popular de la lista, pero
el caso de Minecraft destaca más en el sentido de generación procedural
de mundos ya que es algo mucho más claro y una gran parte de lo que le
aporta la diversión.</p>

<p>El jugador comienza creado un nuevo mundo, este se genera a partir de
una semilla, que es una cadena de caracteres que se puede introducir
manualmente o dejar al mismo juego que cree una aleatoria. A partir de
esta semilla se crear un mundo completo con campos, bosques, montañas,
mares, cuevas, animales y demás elementos naturales. Además podemos
encontrar lo que se llaman biomas, que representan zonas de distinto
clima, como pueden ser zonas desérticas, nevadas, montañosas, praderas
soleadas…</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/2009-minecraft-1.jpg" alt="Minecraft" /></p>

<p>Cuando un usuario introduce una semilla al crear una partida obtiene
siempre exactamente el mismo mundo en su estado original. Este es uno de
sus puntos fuertes, puesto que la comunidad de usuarios comparte
semillas y coordenadas en ese mundo donde se pueden encontrar
formaciones interesantes y extrañas.</p>

<p>Por entrar un poco más en detalles, como el propio Notch explica en
<a href="http://notch.tumblr.com/post/3746989361/terrain-generation-part-1"><em>este
artículo</em></a>,
el mundo de Minecraft no es realmente infinito, a pesar de que no haya
límites propios. Esto es debido a que el mundo se renderiza en trozos
(chunks) de 16x16x128 bloques. El offset o separación entre estos
bloques se basa en enteros de 32 bits en un rango de -2 billones a +2
billones. Al pasar ese rango el juego comienza a sobrescribir los
antiguos chunks con nuevos y cuando pasas cierta distancia, los bloques
que usan enteros para su posicion comienzan a actuar de manera extraña e
inestable.</p>

<p>En cuanto a la generación del terreno en sí, al inicio del desarrollo se
hacía uso de un mapa de alturas 2D utilizando el <strong>ruido de Perlin</strong>
para obtener la “forma” del mundo. De hecho se usaban varios de estos
mapas para obtener detalles como la elevación, la “rugosidad”, y otro
para detalles locales concretos (como biomas). Pero aunque se trataba de
un método sencillo y muy rápido, el hecho de ser 2D tenía la desventaja
de generar formaciones simples y aburridas, por ejemplo no se podían
crear salientes de montañas, donde en una misma zona tendríamos dos
alturas diferentes.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/2009-minecraft-2.jpg" alt="Minecraft" /></p>

<p>Así que en vez de mapas 2D, se comenzó a utilizar algo así como ruido de
Perlin 3D, esto quiere decir que, en vez de tratar el ruido como simple
altura sobre el terreno, lo que se tenía en cuenta era la densidad del
ruido. De este modo cualquier valor por debajo de 0 sería aire, y por
encima de 0 tendríamos terreno.</p>

<h3 id="the-binding-of-isaac-2011">The Binding of Isaac (2011)</h3>

<p>Otro juego que voy a nombrar brevemente es <strong>The Binding of Isaac</strong>
diseñado por <strong>Edmund McMillen</strong>, conocido por el exitoso <strong>Super Meat
Boy</strong>. Se trata de un juego al más puro estilo <strong>The Legend Of Zelda</strong>
en sus versiones clásicas 2D, donde encontramos mazmorras con
habitaciones contiguas e independientes, algunas con roles específicos
como las que guardan un ítem especial tipo mapa, llave o jefe.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/2011-the-binding-of-isaac.jpg" alt="The Binding of Isaac" /></p>

<p>El proceso de creación de las habitaciones es incluso más simple y
trivial que en otros juegos como el clásico Rogue, pero el verdadero
interés se encuentra en la gran variedad y probabilidad de encontrar los
diferentes tipos de objetos, que hacen que una partida pueda resultar
más complicadas que otras.</p>

<p>Mi interés por este juego reside en que es similar a lo que he
desarrollado para este proyecto, donde tenemos una jugabilidad estilo
Zelda, con un estilo visual similar, pero en mi caso incluyo una
generación o distribución de habitaciones y pasillos más variable, como
veíamos en Rogue.</p>

<h3 id="no-mans-sky-2015">No Man’s Sky (2015)</h3>

<p>Para finalizar con estos análisis vamos a echar un vistazo a lo que está
por venir, más en concreto al prometedor <strong>No Man’s Sky</strong>.</p>

<p><strong>No Man’s Sky</strong> se presentó por primera vez en los premios Spike’s VGX
de Diciembre de 2013 como, en principio, un exclusivo para Playstation
4. Está siendo desarrollado por los británicos Hello Games, conocidos
por Joe Danger. Pero esta nueva creación, que tiene como fecha de
lanzamiento Mayo de 2015, es algo completamente distinto a Joe Danger.</p>

<p>No Man’s Sky se presenta como un juego de aventuras de ciencia ficción
de tipo sandbox donde el jugador podrá explorar una gran variedad de
mundos, llenos de vida, criaturas, océanos profundos. Además incluye
otro aspecto de exploración y batallas espaciales.</p>

<p>En cierta manera algo como lo que hemos visto con Elite (1984) pero
elevado a la máxima potencia, uniendo elementos de generación de
criaturas y otro tipo de vida, todo esto utilizando técnicas
procedurales tanto para la vida animal como para los mismos planetas y
distribución de estos.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/2015-no-mans-sky-1.jpg" alt="No Man’s Sky" /></p>

<p>En este caso no se trata de que cada nueva partida sea diferente, sino
de un <strong>mundo persistente</strong> donde todos los jugadores juegan online pero
aparecen en lugares tan apartados que será raro encontrarse con otros
jugadores a no ser que estos compartan una posición.</p>

<p>Para poner en perspectiva la inmensidad del universo que quieren
presentar, podremos encontrar la cifra exacta de
<strong>18.446.744.073.709.551.616 planetas</strong> y para pasar en cada uno un
segundo harían falta <strong>585 mil millones</strong> de años. Sin embargo, la
inmensa mayoría, similar a un universo real, no serán planetas muy
interesantes y solo un 10% de estos tendrán vida, lo cual ya es un
número vertiginoso de planetas.</p>

<p><img src="2015-01-21-Jugando-con-mazmorras/2015-no-mans-sky-2.jpg" alt="No Man’s Sky" /></p>

<p>De momento no he podido encontrar mucho de las técnicas que utilizan
para generar todo este contenido, solo he podido ver que utilizan algo
similar a la creación de especies en Spore pero de manera automática y
simplemente han <a href="https://www.youtube.com/watch?v=9NWpdyQXzHw"><em>comentado en alguna entrevista</em></a> que realmente no utilizan
nada demasiado complicado para generar tal inmensidad de mundos,
probablemente sea una conjunción de muchas de las técnicas que ya hemos
visto en otros juegos.</p>
 -->
  </div>
  
  <div>
    <h3 class="post-title">
    <a href="/blog/2015/Procedimental/">
    Procedimental
    </a>
    </h3>
    <span class="post-date">06 Jan 2015</span>
    <!-- <p>Hablando en términos generales, la <strong>generación procedimental</strong>, o
<strong>generación por procedimientos</strong>, es eso mismo, generar <strong>contenido</strong>
por medio <strong>algoritmos</strong> en vez de manera manual. Suele estar
relacionado con aplicación de computación gráfica y diseño de niveles en
videojuegos.</p>

<p>Pero vamos a usar una definición más precisa para este proyecto y
describir la generación procedimental de contenido como <strong>la creación de
contenido para videojuegos mediante algoritmos y con una limitada e
indirecta intervención del usuario</strong>.</p>

<h3 id="procedimental-o-procedural">¿Procedimental o procedural?</h3>

<p>La razón por la que planteo esta pregunta es porque si buscamos en la
Real Academia Española (RAE) la palabra <strong>procedimental</strong> obtenemos la
siguiente definición:</p>

<blockquote>
  <p><em>“adj. Perteneciente o relativo al procedimiento (método de ejecutar
algunas cosas).”</em></p>
</blockquote>

<p>Pero si buscamos <strong>procedural</strong> no encontramos nada, y es que esta
palabra es constantemente utilizada incorrectamente como anglicismo de
la palabra, probablemente porque podría pasar por una palabra española y
porque es más rápida y sencillo de pronunciar. En entornos no académicos
este anglicismo es la palabra más utilizada por encima de la que
encontramos en la RAE.</p>

<p>En cualquier caso no quiero ser demasiado meticuloso con el uso de estas
palabras y quiero dejar claro que en este documento voy a intentar
utilizar la versión correcta “<strong>procedimental</strong>”, pero que tanto
procedimental como procedural son dos palabras que se refieren a lo
mismo y que ambas son utilizadas con la misma frecuencia al hablar de
este tema.</p>

<h3 id="y-a-qu-nos-referimos-con-contenido">¿Y a qué nos referimos con contenido?</h3>

<p>Pues prácticamente a casi todo lo que podemos encontrar en el juego,
desde <strong>objetos</strong> físicos a las mismas <strong>estadísticas</strong> o
<strong>propiedades</strong> de estos, así como la <strong>música</strong>, <strong>historia</strong> y
<strong>misiones</strong> e incluso las propias <strong>reglas</strong> del juego. Aspectos que
quedarían fuera de esta definición serían básicamente el mismo motor del
juego o la inteligencia artificial, aunque para esta última existen
muchos estudios y métodos de aprendizaje automático que en cierta manera
se asemejan a la definición de generación procedimental de contenido,
pero realmente no generan nuevo contenido en sí.</p>

<p>Otro aspecto del <strong>contenido</strong> que se genere es que debe hacer el juego
“<strong>jugable</strong>”. Se debe poder terminar un nivel generado o utilizar un
objeto generado con estas técnicas, que tenga una <strong>utilidad</strong> dentro
del tipo de asset al que pertenece. Si es un arma, deberíamos poder
usarla para luchar contra enemigos, si es una decoración de escenario,
debería estar en el contexto adecuado, situada por el nivel o habitación
en una posición razonable.</p>

<h3 id="videojuegos">Videojuegos</h3>

<p>Este es un término mucho más difícil de definir, ya que existen muchos
géneros que podrían decirse que están al borde de lo que es un
videojuego o cualquier otro tipo de obra audiovisual interactiva.</p>

<p>Una de las definiciones más clásicas detalla un videojuego como</p>

<blockquote>
  <p><em>“Dispositivo electrónico que permite, mediante mandos apropiados,
simular juegos en las pantallas de un televisor o de un ordenador.”</em></p>
</blockquote>

<p>De la RAE:
<a href="http://buscon.rae.es/drae/srv/search?val=videojuego"><em>http://buscon.rae.es/drae/srv/search?val=videojuego</em></a></p>

<p>En la Wikipedia tenemos una definición más preciso</p>

<blockquote>
  <p><em>“Un videojuego o juego de video es un juego electrónico en el que una o
más personas interactúan, por medio de un controlador, con un
dispositivo dotado de imágenes de vídeo. Este dispositivo electrónico,
conocido genéricamente como «plataforma», puede ser una computadora, una
máquina arcade, una videoconsola o un dispositivo portátil (un teléfono
móvil, por ejemplo). Los videojuegos son, hoy por hoy, una de las
principales industrias del arte y el entretenimiento.”</em></p>
</blockquote>

<p>Pero tampoco es el objetivo de este documento indagar más en la
definición de videojuego, pero si en el papel de la generación
procedimental de contenido para estos y como afecta los distintos
aspectos de jugabilidad y diversión.</p>

<p>Por lo tanto la generación procedimental implica el uso de
procedimientos o algoritmos computacionales para crear algo en un
videojuego. Más concretamente algunos ejemplos de esto puede ser:</p>

<ul>
  <li>
    <p>Una herramiento que crear mazmorras para un juego de aventuras como <strong><em>The Legend of Zelda</em></strong> sin la intervención de la entrada de parámetros por parte del usuario.</p>
  </li>
  <li>
    <p>Un sistema que genera un tablero de juego con cierta combinación de reglas y parámetros. El algoritmo escoge sobre una reglas y parámetros base para crear nuevo contenido usando la combinación de estos.</p>
  </li>
  <li>
    <p>Un motor que funciona como middleware con otro motor de juego para poblar de vegetación un mundo virtual, independientemente de cómo haya sido creado este mundo.</p>
  </li>
</ul>

<h3 id="y-por-qu-generar-contenido-de-manera-procedimental">¿Y por qué generar contenido de manera procedimental?</h3>

<p>Ahora que sabemos los conceptos básicos de lo que significa la
generación procedimental de contenido, tenemos que preguntarnos por qué
y para qué queremos usar técnicas de este tipo cuando podríamos
simplemente diseñar el contenido.</p>

<p>Una de las razones más obvias surge de esto mismo, generar contenido
<strong>manualmente</strong> conlleva, normalmente, tener a un <strong>diseñador</strong> o
<strong>artista</strong> para hacer esto, con el consiguiente <strong>coste</strong> de
mantenimiento de esa persona en cuanto a sueldo y tiempo, ya que algo
creado por alguien suele tardar más que si lo hiciera un algoritmo.
Dependiendo del <strong>tipo de proyecto</strong>, las <strong>plataformas</strong> donde se
quiera publicar y el <strong>presupuesto</strong> del equipo de desarrollo en el que
nos encontremos esto puede ser realizable o simplemente imposible de
soportar.</p>

<p>Hablando de plataformas, un buen ejemplo de lo tenemos en la era de
principios de los <strong>80</strong>, cuando las <strong>computadoras</strong> caseras eran tan
<strong>limitadas técnicamente</strong>, sobretodo en espacio en disco, lo que hacía
imposible incluir todos los recursos o “assets” para hacer juegos
medianamente grandes. De hecho el uso de técnicas procedimentales en
videojuegos viene de esto mismo, y como veremos algunos juegos de
entonces, como Rogue, fueron los precursores de la generación de
contenido de este tipo.</p>

<p><img src="2015-01-06-Procedimental/BBC_Micro_Front_Restored.jpg" alt="BBC Micro" /></p>

<p><sub>Los BBC Micro fueron una serie de microcomputadores que se hicieron bastante populares al principio de la década de los 80 en el Reino Unido. Tuvieron varios lanzamientos de videojuegos que generaban contenido con técnicas procedimentales.</sub></p>

<p>Hoy en día ya no tenemos esas limitaciones técnicas, a no ser que las queramos imponer nosotros mismos, ni siquiera en dispositivos móviles, que hace años que incluyen memoria lo suficientemente rápida y amplia como para incluir el contenido necesario para el juego. Por ello actualmente la generación de contenido procedimental es algo que viene ligado al mismo diseño del juego. Como es el caso de este mismo proyecto, el propio diseño del juego favorece el uso de estas técnicas para generar una infinidad de situaciones que son lo suficientemente distintas como alargar su vida durante cientos de horas. Y los ejemplos más representativos de esto puede que sean Minecraft y Spenlunky, juegos muy diferentes en su jugabilidad y ritmo, pero que independientemente del número de veces que se jueguen, siempre pueden brindar una experiencia diferente a la anterior.</p>

<p>Pero esto no solo viene ligado a lo que el diseñador del juego quiere,
sino a cómo, hoy en día, se consume el contenido audiovisual. En una era
donde estamos saturados con entretenimiento desde los móviles,
computadores y demás dispositivos electrónicos conectados a internet, la
manera en la consumimos contenido es mucho más rápida que antes, no
tenemos el tiempo suficiente para probar todo, y mucho menos para verlo
o jugarlo de principio a fin. Por esto tiene más sentido la creación de
obras que se puedan consumir de forma episódica y de forma
autoconclusiva. En el caso de los videojuegos, que cada partida tenga un
inicio y un fin, independientemente de que luego el usuario pueda ver un
progreso global a lo largo de las diferentes sesiones. En este sentido
la generación de contenido mediante técnicas procedimentales son
realmente adecuadas para producir una experiencia distinta, si no única,
en cada partida.</p>

<h3 id="contenido-a-medida-del-usuario">Contenido a medida del usuario</h3>

<p>Usando métricas y redes neuronales y midiendo como el jugador responde
antes ciertas situaciones, el nuevo contenido generado podría ser
manipulado dependiendo de los gustos y necesidades del jugador o mejorar
su aprendizaje y adaptabilidad a las mecánicas del juego. De la misma
manera puede ayudar a la creatividad, produciendo situaciones
radicalmente diferentes a las que podríamos esperar en algo creado
manualmente por un humano, ofreciendo una solución válida pero, a su
vez, inesperable.</p>

<p>Por supuesto no creo que haga falta ni decir que estas técnicas generan
reticencia entre los diseñadores y artistas, a los que les hace perder
el control creativo sobre ciertos elementos del videojuego. Este es uno
de los claros motivos por lo que algo como la generación procedural de
texturas, que hace unos años prometía ser una buena solución a este
tedioso proceso de creación de assets, ha caído en el olvido cuando hoy
en día las herramientas de diseño proporcionan una facilidad de uso que
permite trabajar muy rápidamente a los artistas y con total control
creativo.</p>

<p>Pero el uso de técnicas procedimentales también puede ayudar a entender
el diseño. Al diseñar esos mismos procedimientos estamos siendo
afrontados con las limitaciones, reglas y problemas que un diseñador o
artista tiene que afrontar a la hora de trabajar, nos ayuda a entender
este proceso de creación manual de contenido porque tenemos que tener en
cuenta y entender este proceso manual para poder automatizarlo.</p>

<h3 id="propiedades-deseadas-en-la-generacin-del-contenido">Propiedades deseadas en la generación del contenido</h3>

<p>Las soluciones basadas en generación procedimental de contenido tiene
una serie de propiedades deseables o requeridas que pueden ser
diferentes para cada aplicación, algunas de estas propiedades comunes
pueden ser:</p>

<ul>
  <li>
    <p><strong>Velocidad</strong>: los requerimientos de velocidad puede variar notablemente según el rango de la aplicación. Normalmente es necesario que esta sea superior a como trabajaría un humano si está realizando un trabajo que se considera similar, pero esto no es tan importante si lo que requiere el proyecto es la creación de contenido de manera creativa y que solo se puede proporcionar por estos mecanismos algorítmicos.</p>
  </li>
  <li>
    <p><strong>Confiabilidad</strong>: el generador de contenido debe garantizar que este se crea dentro de unos criterios de calidad. Debe cumplir una reglas o parámetros, que en mayor parte son establecidas de manera fija en el propio algoritmo, aunque también puede ser el caso en el que el usuario tenga algo de influencia sobre estos, siempre de manera inconsciente o indirecta.</p>
  </li>
  <li>
    <p><strong>Control</strong>: sería deseable proporcionar cierto control sobre este, permitiendo especificar ciertos aspectos iniciales del mismo contenido que se va a crear. Por ejemplo estaríamos hablando de indicar que paleta de colores o texturas a utilizar en cierta situación, si las rocas deberían ser más suaves o agudas, el rango de tamaños que estas pueden tomar, etc. Pero demasiado control rompe el propio concepto y nunca debe caer en lo predecible. Cuando el resultado de un proceso de generación procedimental es demasiado predecible entonces es que se está haciendo mal.</p>
  </li>
  <li>
    <p><strong>Expresividad y diversidad</strong>: medir la expresividad es difícil y generar contenido que es diverso a la vez que cumple cierta calidad no es nada trivial. Entre generar el contenido de manera totalmente aleatoria y probablemente de poca calidad o generar contenido muy predecible hay que encontrar un compromiso intermedio, con suficiente diversidad a la vez que calidad.</p>
  </li>
  <li>
    <p><strong>Creatividad y credibilidad</strong>: generalmente queremos que el contenido no parezca creado por un generador automático, sino que parezca diseñado por una persona.</p>
  </li>
</ul>
 -->
  </div>
  
  <div>
    <h3 class="post-title">
    <a href="/blog/2015/El-videojuego/">
    El videojuego
    </a>
    </h3>
    <span class="post-date">05 Jan 2015</span>
    <!-- <p>Aunque acompañaré el proyecto con un documento de diseño detallado sobre el videojuego, voy a explicar brevemente la idea principal de este y que elementos incluirá para hacernos una idea.</p>

<h2 id="descripcin-y-objetivos">Descripción y objetivos</h2>
<p>Se basa en los clásicos juegos estilo rogue-like, pero trasladado a un entorno de aventuras y puzles tipo The Legend of Zelda (como el de Super Nintendo).</p>

<p>El personaje principal tendrá una barra de vida, distintas armas (solo una equipada), objetos para recuperar vida, objetos especiales de misión…</p>

<p>Consistirá en un mapa externo donde encontraremos acceso a las distintas mazmorras y posiblemente a alguna tienda donde comprar pociones y otros objetos.</p>

<p>Por otro lado tendremos las mazmorras. Estas se generan de manera procedimental, siendo siempre distintas al salir y volver a entrar o al morir completamente y reiniciar el juego desde el mapa o siendo iguales siempre dentro de la misma partida, según vea cual es el método más divertido y menos frustrante.</p>

<p>Las mazmorras consistirán en:</p>

<ul>
  <li>Habitaciones conectadas entre sí por pasillos.</li>
  <li>Objetos comunes para mejorar o recuperar la vida.</li>
  <li>Objetos tipo armas arrojadizas.</li>
  <li>Objetos especiales de mazmorra como puedan ser mapas, brújulas, llaves para abrir puertas o cofres…</li>
  <li>Enemigos que pueden atacar al personaje y este también puede atacarlos usando el arma principal o lo que se encuentre por el camino.</li>
  <li>Trampas como paneles de pinchos, fosos, cofres falsos…</li>
  <li>Cada habitación tiene un rol (puzle, llave, etc.)</li>
  <li>Jefe final de mazmorra (Objetivo opcional)</li>
</ul>

<p>Tanto la distribución de las habitaciones como de todo lo demás se generará de manera procedimental, siempre habiendo un mapa y un jefe (Objetivo opcional). Los demás elementos variarán según la dificultad que se le quiera imprimir a la mazmorra, que irá aumentando según se conquisten más mazmorras.</p>

<p>El número de mazmorras será fijo (unas 7 u 8) y el juego tendrá un final o quizá lo haga infinito, llegando a un nivel en que las mazmorras no se sean más grandes o complicadas pero la dificultad sea suficiente para que el jugador experimentado pueda morir con la misma posibilidad. Esto lo decidiré cuando haga pruebas sobre una versión casi terminada del juego, ya que no sería muy difícil intercambiar entre ambas.</p>

<h2 id="aspecto-visual">Aspecto visual</h2>
<p>Visualmente será un juego 3D con vista aérea, posiblemente tipo isométrica u ortográfica como la que podemos encontrar en el juego Monument Valley.</p>

<p>El aspecto en general tendrá un estilo con formas simples y con texturas pixeladas como vemos en Minecraft que le dan un toque a dibujo animado, como podemos ver en la textura de tierra y césped.</p>

<p><img src="2015-01-05-El-videojuego/minecraft-textura.jpg" alt="Textura minecraft" /></p>

<p>Los objetos en general serán modelos 3D, pero es posible que utilice sprites 2D para personajes y enemigos. Esta técnica visual se conoce como <a href="http://www.gamasutra.com/view/feature/130911/dynamic_2d_imposters_a_simple_.php">billboarding</a> y se refiere a que los sprites siempre miran a cámara, como lo hacía Doom. Además porque es un técnica que me agrada, otro de los motivos de escoger este estilo es porque los modelos 3D son más difíciles de animar correctamente y no es ese el objetivo del proyecto. En cualquier caso, si al final escogiera 3D para los modelos de los personajes, intentaría hacer algo simple, formado por cubos, que no necesite mucha animación y trabajo de texturas.</p>

<h2 id="herramientas">Herramientas</h2>
<p><strong>Motor de juego</strong><br />
Debido a que el objetivo principal del juego es demostrar la generación procedimental de las mazmorras se va a utilizar Unity en su versión free como motor de juego. Unity proporciona diversas herramientas integradas con un editor, estas incluyen un motor gráfico, motor de físicas, sistema de audio y sistema de GUI entre otros, suficiente para cubrir las necesidades de desarrollo.</p>

<p><strong>Diseño de assets</strong><br />
Para los elementos 2D del juego como los botones de menú, títulos y resto de elementos del HUD, así como otros elementos 2D como texturas se utilizará The Gimp o Paint.net, ambos editores gratuitos. Para el diseño de los assets 3D se hará uso de Blender.</p>

<h2 id="requisitos-hardware-y-software">Requisitos hardware y software</h2>
<p>Estos son los requisitos que deberá cumplir el sistema cliente para ejecutar el juego:</p>

<ul>
  <li>Windows 7 o superior.</li>
  <li>Teclado y ratón o mando de juego con soporte para XInput.</li>
  <li>Sistemas basados en Linux.</li>
  <li>Tarjetas gráficas HD Intel 3000 o superior, NVIDIA o ATI.</li>
</ul>
 -->
  </div>
  
</div>
<div class="pagination">
  
  <span class="pure-button pure-button-disabled">Newer</span>
  
  
  <a class="pure-button" href="/blog/page2/">Older</a>
  
</article>
  </div>
  <footer class="site-footer">
  <div>
    <p class="text"><a href="mailto:rub3nmv@gmail.com">rub3nmv@gmail.com</a><br>
    This site was made with <a href="http://jekyllrb.com/">Jekyll generator</a>, <a href="http://purecss.io/">PureCSS</a> and <a href="http://fortawesome.github.io/">Font Awesome</a>.</p>
  </div>
</footer> <!-- <script src="/js/jquery-1.11.3.min.js"></script> -->
<script src="/js/minified-legacyie.js"></script>
<script src="/js/utils.js"></script>

</body>

</html>
