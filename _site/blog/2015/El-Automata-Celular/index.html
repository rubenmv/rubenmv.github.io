<!DOCTYPE html>
<html>
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <title>
  
  El Autómata celular &middot; Rubén Martínez Vilar
  
  </title>
  <!-- CSS -->
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link href='http://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Roboto+Slab:700,400' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/pure-min.css">
  <!--[if lte IE 8]>
  <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.6.0/grids-responsive-min.css">
  <!--<![endif]-->
  <link rel="stylesheet" href="/css/main.css">
  <!-- Icons -->
  <link rel="shortcut icon" href="/img/favicon.ico">
  <!-- RSS -->
  <!-- <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> -->
</head>

<body>
  <header class="main-header">
    <!-- MAIN MENU -->
<nav class="site-menu pure-menu pure-menu-horizontal">
  <a href="/" class="pure-menu-heading pure-menu-link">Rubén Martínez Vilar</a>
  <ul class="pure-menu-list">
    <li class="pure-menu-item"><a class="pure-menu-link" href="/#about">About</a></li>
    <li class="pure-menu-item"><a class="pure-menu-link" href="/#projects">Projects</a></li>
    <li class="pure-menu-item"><a class="pure-menu-link" href="/blog/#posts">Blog</a></li>
    <li class="pure-menu-item"><a class="pure-menu-link" href="/#contact">Contact</a></li>
    <li class="pure-menu-item"><a class="pure-menu-link" href="https://dl.dropboxusercontent.com/u/15074300/RubenMartinezVilar-CV.pdf">CV</a></li>
  </ul>
</nav>

<div class="pure-menu pure-menu-horizontal">
    <ul class="pure-menu-list">
        <li class="pure-menu-item pure-menu-selected"><a href="#" class="pure-menu-link">Home</a></li>
        <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
            <a href="#" id="menuLink1" class="pure-menu-link">Contact</a>
            <ul class="pure-menu-children">
                <li class="pure-menu-item"><a href="#" class="pure-menu-link">Email</a></li>
                <li class="pure-menu-item"><a href="#" class="pure-menu-link">Twitter</a></li>
                <li class="pure-menu-item"><a href="#" class="pure-menu-link">Tumblr Blog</a></li>
            </ul>
        </li>
    </ul>
</div>
  
  </header>
  <div class="page-content">
    <div class="post">

  <header class="post-header">
    <h3 class="post-title">El Autómata celular</h3>
    <p class="post-meta">Mar 25, 2015</p>
  </header>

  <article class="post-content">
    <p>El segundo tipo de algoritmo que vamos a estudiar entra dentro de los algoritmos utilizados para representar sistemas naturales, como cuevas, bosques o manadas de animales.</p>

<p>El concepto de <strong>autómata celular</strong> fue presentado originalmente en los <strong>años 40</strong> por Stanislaw Ulam y John Von Neumann cuando trabajaban en el laboratorio nacional de Los Alamos. Fue estudiado ocasionalmente durante las siguientes dos décadas pero no fue hasta los 70 en que <strong>John Horton Conway</strong> creó el “Juego de la vida” (<a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game Of Life</a>) que despertó el interés en el entorno académico.</p>

<h2 id="conways-game-of-life">Conway’s Game Of Life</h2>
<p>Este juego consiste en una serie de puntos llamados células que evolucionan con el tiempo basándose en la interacción con sus vecinas. Si una célula tiene <strong>menos de dos</strong> vecinas, entonces <strong>muere</strong>, debido a la falta de población, con <strong>dos o tres</strong> vecinas se mantiene <strong>viva</strong> durante esa generación, si tiene <strong>más de tres</strong> entonces <strong>muere</strong> por sobrepoblación. Si una célula muerta (un espacio vacío) tiene exactamente tres vecinos, entonces esta se convierte en una célula viva, representando un proceso de reproducción.</p>

<p>Antes de comenzar el juego se establecen ciertas condiciones para la situación inicial, pero a partir de ahí el jugador no tiene más interacción con este, el juego evoluciona por sí solo.</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/Game-Of-Life.gif" alt="Game of life" /></p>

<p>Durante los <strong>años 80 Stephen Wolfram</strong> se ocupó del estudio del autómata celular sobre una sola dimensión, y en 2002 publicó su libro “<strong>Un nuevo tipo de ciencia</strong>”, donde argumenta que este tipo de métodos pueden ser utilizados en otros campos de la ciencia como la criptografía.</p>

<h2 id="aplicacin-para-generacin-procedural-de-cuevas">Aplicación para generación procedural de cuevas</h2>
<p><strong>Jim Badcock</strong> publicó hace unos años su aplicación de los <a href="http://www.jimrandomh.org/misc/caves.html">autómatas celulares en la creación procedimental de cuevas</a>, mostrando su potencial para la representación de sistemas naturales, al menos como base, ya que el proceso requiere un refinamiento posterior.</p>

<p>El <strong>proceso</strong> consiste en lo siguiente:</p>

<ol>
  <li>
    <p>Generamos un lienzo inicial utilizando la técnica de ruido blanco, es decir, dividimos el mapa en celdas y las recorremos decidiendo aleatoriamente si esta se rellena o se queda vacía. Para evitar situaciones no deseables o extrañas establecemos un porcentaje que indique la probabilidad de que esta se convierta en pared. Por ejemplo, decimos que la probabilidad es del 40%, generamos un número aleatorio entre 0 y 100 y si este es inferior o igual al 40 entonces generamos una pared.</p>
  </li>
  <li>Recorremos el mapa de nuevo ahora aplicando las reglas del autómata celular:
    <ul>
      <li>Si la celda es pared y tiene menos de 3 vecinas de tipo pared, entonces se convierte en espacio vacío.</li>
      <li>Si la celda está vacía y tiene 5 o más vecinas de tipo pared, entonces esta también se convierte en pared.</li>
    </ul>
  </li>
  <li>Cuando hemos recorrido todas las celdas el algoritmo termina, aunque es posible realizar más iteraciones, dependiendo de los resultados a obtener.</li>
</ol>

<p>Vamos a ver ejemplos generados a partir de la implementación que he realizado sobre Unity:</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/cellular-automata-1.PNG" alt="Cellular automata 1" />
Tablero inicial generado aleatoriamente con una probabilidad de paredes del 35%.</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/cellular-automata-2.PNG" alt="Cellular automata 2" />
Este es el resultado al terminar el algoritmo con un solo pase, podemos ver que se generan zonas o espacios abiertos distinguibles unos de otros. También observamos uno de los problemas del algoritmo, y es que es poco consistente, y muy frecuentemente obtenemos zonas inconexas que deberemos procesar posteriormente para unirlas al sistema principal de habitaciones. A veces estas zonas desconectadas están separadas simplemente por distancias de 1 o 2 celdas, pero como podemos ver en este mismo ejemplo, en la zona superior derecha tenemos una zona relativamente grande con una separación de la zona principal de al menos 3 celdas, por lo que resultaría difícil determinar programáticamente como esa zona debería unirse.</p>

<p>Por otro lado esto puede ser interesante para juego como Minecraft, donde podemos encontrar en cuevas, con mucha frecuencia, zonas totalmente aisladas a las que se debe acceder usando el pico o la pala. En ese caso específico este algoritmo parece actuar correctamente.</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/cellular-automata-3.PNG" alt="Cellular automata 3" />
Aquí tenemos otro ejemplo, esta vez con dos pases. Ahora hemos conseguido que todos los espacios estén conectados de alguna manera. También se han eliminado celdas sueltas de una unidad al realizar este segundo pase, lo cual puede ser beneficioso para eliminar ruido innecesario pero al mismo tiempo perjudicial porque le quita un poco de la aleatoriedad que podemos encontrar en las cuevas naturales.</p>

<p>Otro problema de realizar este segundo pase es que perdemos la distinción entre las distintas secciones o habitaciones de la cueva, por lo que nos queda un espacio abierto con algunos rincones más cerrados.</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/cellular-automata-4.PNG" alt="Cellular automata 4" />
Con los mismo parámetros pero con diferentes dimensiones. Conseguimos conectar todos los espacios pero el centro está demasiado despoblado.</p>

<p><img src="images/posts/2015-03-25-El-Automata-celular/cellular-automata-5.PNG" alt="Cellular automata 5" />
Si subimos la probabilidad de paredes al 40% y al realizar dos pases obtenemos un resultado mejor.</p>

<p>Conclusión
Haciendo varias pruebas puedo llegar a la conclusión de que los mejores resultados los obtengo con una probabilidad de obtener paredes del 35% al 40% y uno o dos pases según este porcentaje, cuanto más se acerca al 40% mejores resultados obtendremos con dos pases que solo con uno.</p>

<p>Uno de los principales problemas con este algoritmo, como ya hemos visto, es el poco control sobre el resultado final, demasiadas aleatoriedad en la creación de los distintos espacios que componen la cueva.</p>

  </article>

</div>

  </div>
  <footer class="site-footer">
  <div>
    <p class="text"><a href="mailto:rub3nmv@gmail.com">rub3nmv@gmail.com</a><br>
    This site was made with <a href="http://jekyllrb.com/">Jekyll generator</a>, <a href="http://purecss.io/">PureCSS</a> and <a href="http://fortawesome.github.io/">Font Awesome</a>.</p>
  </div>
</footer> <!-- <script src="/js/jquery-1.11.3.min.js"></script> -->
<script src="/js/minified-legacyie.js"></script>
<script src="/js/utils.js"></script>

</body>

</html>
